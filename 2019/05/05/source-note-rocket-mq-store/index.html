<!DOCTYPE html>













<html class="theme-next gemini" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">





















  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=sans-serif:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext">
  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="分析 rocketmq 的如何实现消息的存储">
<meta name="keywords" content="阅读笔记,rocketmq">
<meta property="og:type" content="article">
<meta property="og:title" content="【阅读笔记】rocketmq 消息存储 （四）">
<meta property="og:url" content="http://yoursite.com/2019/05/05/source-note-rocket-mq-store/index.html">
<meta property="og:site_name" content="Deer&#39;s blog">
<meta property="og:description" content="分析 rocketmq 的如何实现消息的存储">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/05/05/source-note-rocket-mq-store/rocketmq_store_struct.png">
<meta property="og:image" content="http://yoursite.com/2019/05/05/source-note-rocket-mq-store/rocketmq_store.png">
<meta property="og:updated_time" content="2019-09-30T13:02:05.804Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【阅读笔记】rocketmq 消息存储 （四）">
<meta name="twitter:description" content="分析 rocketmq 的如何实现消息的存储">
<meta name="twitter:image" content="http://yoursite.com/2019/05/05/source-note-rocket-mq-store/rocketmq_store_struct.png">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/05/05/source-note-rocket-mq-store/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>【阅读笔记】rocketmq 消息存储 （四） | Deer's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Deer's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/05/source-note-rocket-mq-store/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deer">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deer's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【阅读笔记】rocketmq 消息存储 （四）

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-05 21:15:04" itemprop="dateCreated datePublished" datetime="2019-05-05T21:15:04+08:00">2019-05-05</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>分析 rocketmq 的如何实现消息的存储</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>store 模块定义了 rocketmq 如何将消息存储在文件系统。只要消息被刷盘持久化至磁盘文件中，那么 Producer 发送的消息就不会丢失，而 Consumer 也就肯定有机会去消费这条消息。</p>
<h2 id="消息存储的层次结构"><a href="#消息存储的层次结构" class="headerlink" title="消息存储的层次结构"></a>消息存储的层次结构</h2><p><img src="/2019/05/05/source-note-rocket-mq-store/rocketmq_store_struct.png" alt="rocketmq 存储结构"></p>
<p>rocketmq 文件存储模型层次结构如上图所示，概念上可以分为 5 层：</p>
<ol>
<li>rocketmq 业务处理器层，是 Broker 端对消息进行读取和写入的业务逻辑入口</li>
<li>rocketmq 数据存储组件层，主要是 rocketmq 的存储核心类 DefaultMessageStore，为 rocketmq 消息数据文件的访问入口</li>
<li>rocketmq 存储<strong><em>逻辑对象层</em></strong>，主要是三个模型类 IndexFile、ConsumerQueue 和 CommitLog</li>
<li>封装的文件内存映射层，采用 NIO 中的 MappedByteBuffer 和 FileChannel 完成数据文件读写</li>
<li>磁盘存储层，部署 rocketmq 服务器所用的磁盘</li>
</ol>
<p><img src="/2019/05/05/source-note-rocket-mq-store/rocketmq_store.png" alt="rocketmq 消息存储格式"></p>
<p>存储逻辑对象层说明：</p>
<ol>
<li>单个 broker 的所有消息都保存在 commit log 文件</li>
<li>生产者发送消息到 broker，broker 先写到 commit log</li>
<li>将消息在 commit log 在的位置记录到 consume queue（逻辑消费队列）<br> consume queue 维护了 3 个变量：<br> minOffset 表示 consume queue 中是早一个消息的逻辑下标<br> consumerOffset 表示目前消费到的逻辑下标（保存在 consumerOffset），<br> maxOffset 表示新消息在 consume queue 中的逻辑下标</li>
<li>消费者消费消息时，是按顺序从 consume queue 得到消息的存储位置，然后到 commit log 中取消息内容</li>
<li>consume queue 按 Topic 组合，每个 Topic 下有多个 consume queue</li>
<li>index 文件提供快速查找消息的方法，而且通过 index 文件来找消息不影响消息的消费</li>
</ol>
<p>对于 consume queue， 采用顺序读写，速度较快，而 commit log 写入时是顺序写入，读取进是随机读取，读的效率偏低。<br>消费一条消息需要先读 consume queue 再读 commit log，有一定的开销</p>
<h3 id="CommitLog-格式"><a href="#CommitLog-格式" class="headerlink" title="CommitLog 格式"></a>CommitLog 格式</h3><p>用于保存消息，默认保存在 store/commitlog 目录下，每个文件都是 1GB，按顺序保存消息。</p>
<p>文件名每个都是 20 位，左边补0。第一个文件文件名是 00000000000000000000，起始位置的逻辑位置是 0，即偏移量是0。当第一个文件写满后，第二个文件文件名是 00000000001073741824（1G），起始位置的<strong>逻辑位置</strong>是 1073741824，即当要查找 commitLog 第 1073741825 的位置时，就读第二个文件的第 1 个字节，由此类推。</p>
<p>CommitLog 的内部类 MessageExtBatchEncoder 定义怎么将消息体变成字节流，DefaultAppendMessageCallback 的 doAppend 定义怎么将流读到消息体。一个消息包括以下内容：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>字段简称</th>
<th>字段大小（字节），类型</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>TOTALSIZE</td>
<td>4，Integer</td>
<td>消息总长度</td>
</tr>
<tr>
<td></td>
<td>MAGICCODE</td>
<td>4，Integer</td>
<td>魔术数，CommitLog. MESSAGE_MAGIC_CODE</td>
</tr>
<tr>
<td></td>
<td>BODYCRC</td>
<td>4，Integer</td>
<td>消息体CRC</td>
</tr>
<tr>
<td></td>
<td>QUEUEID</td>
<td>4，Integer</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>FLAG</td>
<td>4，Integer</td>
<td></td>
</tr>
<tr>
<td></td>
<td>QUEUEOFFSET</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td></td>
<td>PHYSICALOFFSET</td>
<td>8，Long</td>
<td>消息在commitLog中的物理起始地址偏移量</td>
</tr>
<tr>
<td></td>
<td>SYSFLAG</td>
<td>4，Integer</td>
<td></td>
</tr>
<tr>
<td></td>
<td>BORNTIMESTAMP</td>
<td>8，Long</td>
<td>消息产生时间戳</td>
</tr>
<tr>
<td>10</td>
<td>BORNHOST</td>
<td>8，byte buffer</td>
<td>消息生产者地址, IP:Port</td>
</tr>
<tr>
<td></td>
<td>STORETIMESTAMP</td>
<td>8，Long</td>
<td>消息在 broker 的时间戳</td>
</tr>
<tr>
<td></td>
<td>STOREHOSTADDRESS</td>
<td>8，byte</td>
<td>buffer 消息存储到broker的地址，IP:Port</td>
</tr>
<tr>
<td></td>
<td>RECONSUMETIMES</td>
<td>4，Integer</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Prepared Transaction Offset</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>BODY LENGTH</td>
<td>4，Integer</td>
<td>BODY 的长度</td>
</tr>
<tr>
<td></td>
<td>BODY</td>
<td>BODY LENGTH</td>
<td></td>
</tr>
<tr>
<td></td>
<td>TOPIC LENGTH</td>
<td>1，byte</td>
<td>TOPIC 的长度</td>
</tr>
<tr>
<td></td>
<td>TOPIC</td>
<td>TOPIC LENGTH</td>
<td></td>
</tr>
<tr>
<td></td>
<td>PROPERTIES LENGTH</td>
<td>2，Short</td>
<td>PROPERTIES 的长度</td>
</tr>
<tr>
<td>20</td>
<td>PROPERTIES</td>
<td>PROPERTIES LENGTH</td>
<td>消息的属性</td>
</tr>
</tbody>
</table>
<h3 id="ConsumeQueue"><a href="#ConsumeQueue" class="headerlink" title="ConsumeQueue"></a>ConsumeQueue</h3><p>默认保存在 store/consumequeue/${Topic}/${queueid} 目录下，每个文件都是 600 万字节（5.7MB）</p>
<p>文件名每个都是 20 位，左边补 0，第一个文件文件名是 00000000000000000000， 与 CommitLog 的规则类似</p>
<p>每个 entry 包含如下内容：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>字段简称</th>
<th>字段大小（字节），类型</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>offset</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td></td>
<td>size</td>
<td>4，Integer</td>
<td></td>
</tr>
<tr>
<td></td>
<td>tagsCode</td>
<td>8，Long</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>记录某个 key 在 commit log 中的位置。索引文件由头，hashSlot，和 index 组成。</p>
<p>文件头包括有如下字段</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>字段简称</th>
<th>字段大小（字节），类型</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>beginTimestamp</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td></td>
<td>endTimestamp</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td></td>
<td>beginPhyOffset</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td></td>
<td>endPhyOffset</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td>5 hashSlotCount</td>
<td>4，Integer</td>
<td></td>
</tr>
<tr>
<td></td>
<td>indexCount</td>
<td>4，Integer</td>
<td>索引的数量</td>
</tr>
</tbody>
</table>
<p>一个 hashSlot 占 4 字节，一共有 hashSlotNum 个（在 MessageStoreConfig.maxHashSlotNum 配置项定义）。一个 hashSlot 的值表示这个 hash 值的 index 的下标<br>index 有如下字段</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>字段简称</th>
<th>字段大小（字节），类型</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>keyHash</td>
<td>4，Integer</td>
<td>散列值</td>
</tr>
<tr>
<td></td>
<td>phyOffset</td>
<td>8，Long</td>
<td><strong>消息 在 commit log 中的位置</strong></td>
</tr>
<tr>
<td></td>
<td>timeDiff</td>
<td>4，Integer</td>
<td>storeTimestamp 到 beginTimestamp 的差</td>
</tr>
<tr>
<td></td>
<td>slotValue</td>
<td>4，Integer</td>
<td>hashSlot 的旧值，表示同样 hash 值的 index 的下标，相当于链表的 pre 指针。用拉链法解决 hash 冲突</td>
</tr>
</tbody>
</table>
<h2 id="消息存储的底层技术"><a href="#消息存储的底层技术" class="headerlink" title="消息存储的底层技术"></a>消息存储的底层技术</h2><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p>将文件内容映射到内存中，这里的映射是<strong>硬盘上文件</strong>的位置与进程<strong>逻辑地址空间</strong>的一一对应，然后文件的读写通过访问这段内存实现，这样就减少了 read / write 等系统调用。</p>
<p>使用 read / write 等系统调用，读操作的话操作系统先将文件的内存加载到<strong>内核</strong>空间，再复制到<strong>用户进程</strong>空间；写操作的话会先将<strong>用户进程</strong>空间复制到<strong>内核</strong>空间再写入磁盘。内存映射文件技术减少了这些中间操作，从而提升效率。</p>
<p>java 中通过 FileChannel 的 map 成员方法可以打开内存映射文件</p>
<h3 id="PageCache-以及文件预热"><a href="#PageCache-以及文件预热" class="headerlink" title="PageCache 以及文件预热"></a>PageCache 以及文件预热</h3><p>系统的所有文件 I/O 请求，操作系统都是通过 page cache 机制实现的。对于操作系统来说，磁盘文件都是由一系列的数据块顺序组成，数据块的大小由操作系统本身而决定，x86 的 linux 中一个标准页面大小是 4KB。</p>
<p>操作系统内核在处理文件 I/O 请求时，首先到 page cache 中查找（page cache 中的每一个数据块都设置了文件以及偏移量地址信息），如果未命中，则启动磁盘 I/O，将磁盘文件中的数据块加载到 page cache 中的一个空闲块，然后再 copy 到用户缓冲区中。</p>
<p>page cache 本身也会对数据文件进行预读取，对于每个文件的第一个读请求操作，系统在读入所请求页面的同时会读入紧随其后的少数几个页面。<strong>因此，想要提高 page cache 的命中率（尽量让访问的页在物理内存中）</strong>，从硬件的角度来说肯定是物理内存越大越好。从操作系统层面来说，访问 page cache 时，即使只访问 1k 的消息，系统也会提前预读取更多的数据，在下次读取消息时, 就很可能可以命中内存。</p>
<p>每当创建一个新的 commit log 内存映射文件，rocketmq 会每隔 4k 写入一个 0，使得整个文件都会加载到内存，然后用 mlock 锁定内存。这样 commit log 的读写都会通过内存进行，可以有效提高消息的 I/O 效率。</p>
<h3 id="LibC-系统调用"><a href="#LibC-系统调用" class="headerlink" title="LibC 系统调用"></a>LibC 系统调用</h3><p>利用 JNA 加载  C Runtime 库，并调用其中的 API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LibC</span> <span class="keyword">extends</span> <span class="title">Library</span> </span>&#123;</span><br><span class="line">    LibC INSTANCE = (LibC) Native.loadLibrary(Platform.isWindows() ? <span class="string">"msvcrt"</span> : <span class="string">"c"</span>, LibC.class);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定系统物理内存，防止被系统换出</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mlock</span><span class="params">(Pointer var1, NativeLong var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">munlock</span><span class="params">(Pointer var1, NativeLong var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉内核如何使用某些映射或共享内存区域</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">madvise</span><span class="params">(Pointer var1, NativeLong var2, <span class="keyword">int</span> var3)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line">LibC.INSTANCE.mlock(var1, var2);</span><br></pre></td></tr></table></figure>
<h2 id="消息存储的功能实现"><a href="#消息存储的功能实现" class="headerlink" title="消息存储的功能实现"></a>消息存储的功能实现</h2><h3 id="MappedFile-amp-MappedFileQueue"><a href="#MappedFile-amp-MappedFileQueue" class="headerlink" title="MappedFile &amp; MappedFileQueue"></a>MappedFile &amp; MappedFileQueue</h3><p>MappedFile 操作内存映射文件，负责用内存映射的方式读写文件。 MappedFile 继承了 ReferenceResource，ReferenceResource 采用引用计数的方式管理资源。</p>
<p>MappedFile 有两种工作方式，由 MessageStoreConfig.isTransientStorePoolEnable 配置项控制</p>
<p>当 MessageStoreConfig.isTransientStorePoolEnable 为 true 时，MappedFile 在 init 会传入 TransientStorePool 对象，并从中取出 ByteBuffer  给 <strong>writeBuffer</strong> 成员赋值；当 MessageStoreConfig.isTransientStorePoolEnable 为 false 时则不传入</p>
<p>当 writeBuffer 非空时，就使用 writeBuffer 进行读写，否则使用 mappedByteBuffer 进行读写</p>
<p>主要区别是 flush 和 commit 方法不同:  </p>
<ol>
<li>使用 writeBuffer，读写操作其实是先写到另外的 byteBuffer，而不是文件映射到的  mappedByteBuffer<br> commit 将 writeBuffer 写入 fileChannel<br> flush 方法调用 fileChannel 的 force，强制将 fileChannel 所有更新写入存储设备，因为这时不使用 mappedByteBuffer 读写，所以不用管 mappedByteBuffer  </li>
<li>使用 mappedByteBuffer<br> commit 方法什么都不做<br> flush 方法调用 mappedByteBuffer 的 force，强制 mappedByteBuffer 的所有更新写入到存储设备  </li>
</ol>
<p>因为 MappedFile 总是多个出现，例如 commit log 就由多个文件组成，所以用列表组织起来，并提供服务。所有对 MappedFile 的操作其实都要经过 MappedFileQueue。</p>
<p>MappedFileQueue 的主要成员有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFileQueue</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  String storePath; <span class="comment">// 文件保存路径</span></span><br><span class="line"></span><br><span class="line">  CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles; <span class="comment">// 保存多个 MappedFile</span></span><br><span class="line"></span><br><span class="line">  AllocateMappedFileService allocateMappedFileService; <span class="comment">// 用于创建新的 MappedFile 并给 MappedFile 预热</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> flushedWhere; <span class="comment">// 记录已经 flush 的位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> committedWhere; <span class="comment">// 记录已经 commit 的位置</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载 storePath 下的所有文件</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 startOffset 位置的 MappedFIle 对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MappedFile <span class="title">getLastMappedFile</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startOffset, <span class="keyword">boolean</span> needCreate)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 mappedFiles 中最后一个 MappedFile 对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MappedFile <span class="title">getLastMappedFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MappedFile mappedFileLast = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于 size 之后可能被其他线程修改，所以要循环读取，并 catch IndexOutOfBoundsException 异常</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.mappedFiles.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mappedFileLast = <span class="keyword">this</span>.mappedFiles.get(<span class="keyword">this</span>.mappedFiles.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                <span class="comment">//continue;</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"getLastMappedFile has exception."</span>, e);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mappedFileLast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除过期的文件，防止过多占用空间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">truncateDirtyFiles</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="commit-log"><a href="#commit-log" class="headerlink" title="commit log"></a>commit log</h3><p>CommitLog 类实现了对 commit log 文件的读写。 CommitLog 文件保存在 ${storePath}/commitlog/ 目录下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  MappedFileQueue mappedFileQueue; <span class="comment">// 读写 mappedFiles</span></span><br><span class="line"></span><br><span class="line">  FlushCommitLogService flushCommitLogService; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  FlushCommitLogService commitLogService; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  AppendMessageCallback appendMessageCallback; <span class="comment">// 用于写 meesage</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读数据</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将逻辑位置 offset 后的内容读出</span></span><br><span class="line">  <span class="comment">// SelectMappedBufferResult 封装了一个 ByteBuffer，可以直接表示读出的内容，不需要做复制操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SelectMappedBufferResult <span class="title">getData</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">boolean</span> returnFirstOnNotFound)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个文件的大小</span></span><br><span class="line">    <span class="keyword">int</span> mappedFileSize = <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getMapedFileSizeCommitLog();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到 offset 所在的 MappedFile</span></span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.findMappedFileByOffset(offset, returnFirstOnNotFound);</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = (<span class="keyword">int</span>) (offset % mappedFileSize); <span class="comment">// pos 就是 offset 在 MappedFile 中的实际位置</span></span><br><span class="line">        SelectMappedBufferResult result = mappedFile.selectMappedBuffer(pos);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 顺序写消息</span></span><br><span class="line">  <span class="function">PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123; <span class="comment">// 处理延时投递</span></span><br><span class="line">        ...</span><br><span class="line">        topic = ScheduleMessageService.SCHEDULE_TOPIC; <span class="comment">// 先将消息写到 SCHEDULE_TOPIC_XXXX 这个 topic</span></span><br><span class="line">        queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line">        ..</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> eclipseTimeInLock = <span class="number">0</span>;</span><br><span class="line">    MappedFile unlockMappedFile = <span class="keyword">null</span>;</span><br><span class="line">    MappedFile mappedFile = mappedFileQueue.getLastMappedFile(); <span class="comment">// 最后一个 MappedFile</span></span><br><span class="line"></span><br><span class="line">    putMessageLock.lock(); <span class="comment">// 这个锁有 ReentrantLock 和用 AtomicBoolean 实现的自旋锁两种实现，取决于配置</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 通过 appendMessageCallback 写消息</span></span><br><span class="line"><span class="comment">         appendMessage 为 appendMessageCallback 提供一个 byteBuffer 参数</span></span><br><span class="line"><span class="comment">         这个 byteBuffer 决定了写到哪个内存（writeBuffer or mappedByteBuffer)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         appendMessageCallback 使用 DefaultAppendMessageCallback 实现，它前面提到的格式将消息写到 byteBuffer</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      result = mappedFile.appendMessage(msg, appendMessageCallback);</span><br><span class="line">      <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">        ...  构造 PutMessageResult</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      eclipseTimeInLock = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line">      beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      putMessageLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ..</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理刷盘</span></span><br><span class="line">    handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 HA</span></span><br><span class="line">    handleHA(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> putMessageResult;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写批量消息与写单个消息类似</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接写数据，这是 slave 写数据时用的</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">appendData</span><span class="params">(<span class="keyword">long</span> startOffset, <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">    putMessageLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(startOffset);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> mappedFile.appendMessage(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      putMessageLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步刷盘-VS-异步刷盘"><a href="#同步刷盘-VS-异步刷盘" class="headerlink" title="同步刷盘 VS 异步刷盘"></a>同步刷盘 VS 异步刷盘</h3><p>handleDiskFlush 处理磁盘的刷新。当使用同步方式时，commit log 写到磁盘后，putMessage 才返回；当使用异步方式时，commit log 写到内存就返回，由专门的线程将内存刷新到磁盘。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 所有的刷盘动作，都是调用 MappedFileQueue 的 flush 方法实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDiskFlush</span><span class="params">(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Synchronization flush</span></span><br><span class="line">    <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> GroupCommitService service = (GroupCommitService) <span class="keyword">this</span>.flushCommitLogService;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123; <span class="comment">// 消息可以加一个属性，使得不用同步方式刷盘</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步方式刷盘，创建一个刷盘的请求，然后等待刷盘完成</span></span><br><span class="line">        <span class="comment">// 使用同步方式时，flushCommitLogService 是 GroupCommitService 类对象</span></span><br><span class="line">        GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GroupCommitService 有两个队列，requestsWrite 和 requestsRead</span></span><br><span class="line">        <span class="comment">// putRequest 会将  request 添加到 requestsWrite 并使用线程开始运行</span></span><br><span class="line">        service.putRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GroupCommitRequest 内部有一个 CountDownLatch， waitForFlush 方法调用 countDownLatch.await</span></span><br><span class="line">        <span class="keyword">boolean</span> flushOK = request.waitForFlush(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">          ... <span class="comment">// 报错</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        service.wakeup(); <span class="comment">// 仅唤醒线程</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Asynchronous flush</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 仅唤醒线程</span></span><br><span class="line">      <span class="comment">// 如果使用 isTransientStorePoolEnable 的话，还需要 commit 再 flush，所以这里需要使用两个不同的线程实现刷盘</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在异步刷盘方式中，flushCommitLogService 是 FlushRealTimeService 类对象</span></span><br><span class="line">        <span class="comment">// 这个线程每隔固定时间调用一次  mappedFileQueue.flush</span></span><br><span class="line">        flushCommitLogService.wakeup();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CommitRealTimeService 每隔固定时间调用一次 mappedFileQueue.commit</span></span><br><span class="line">        <span class="comment">// 然后唤醒 flushCommitLogService，让这个线程做 flush</span></span><br><span class="line">        commitLogService.wakeup();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">GroupCommitService</span> <span class="keyword">extends</span> <span class="title">FlushCommitLogService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">for</span> (GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">            ...</span><br><span class="line">            CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>); <span class="comment">// 刷盘，如果 req 中要求刷盘的位置已经刷过，就不用刷</span></span><br><span class="line">            ...</span><br><span class="line">            req.wakeupCustomer(flushOK); <span class="comment">// 通知到等待 req 的线程</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">          requestsRead.clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.waitForRunning(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">this</span>.doCommit();</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      doCommit(); <span class="comment">// 正常的循环退出后还要再刷盘一次</span></span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="HA（同步双写-VS-异步复制）"><a href="#HA（同步双写-VS-异步复制）" class="headerlink" title="HA（同步双写 VS 异步复制）"></a>HA（同步双写 VS 异步复制）</h3><p>handleHA 实现 master 到 slave 的同步双写，如果是采用异步复制的方法，这个方法会直接返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHA</span><span class="params">(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是不是同步双写</span></span><br><span class="line">  <span class="keyword">if</span> (BrokerRole.SYNC_MASTER == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HAService 有个嵌套类 GroupTransferService</span></span><br><span class="line">    <span class="comment">// GroupTransferService 检查是否已经写到 slave，写完成就通知正在等待的线程</span></span><br><span class="line">    <span class="comment">// 同步双写仍然是通过 slave 往 master 读 commit log 来实现，这里的同步只不过是在 putMessage 中增加了等待，确保同步已经完成</span></span><br><span class="line">    HAService service = <span class="keyword">this</span>.defaultMessageStore.getHaService();</span><br><span class="line">    <span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 slave 是否连接正常，且这个 req 对 slave 来说是不是 OK 的</span></span><br><span class="line">        <span class="keyword">if</span> (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// request &amp; wait</span></span><br><span class="line">          GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">          service.putRequest(request);</span><br><span class="line">          service.getWaitNotifyObject().wakeupAll();</span><br><span class="line">          <span class="keyword">boolean</span> flushOK = request.waitForFlush(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">              ... 报错</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Slave problem</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          ...  报错</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步复制就直接返回</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h3><p>HAService 类实现了 commit log 的 master-slave 同步。broker 启动时，会打开 listen + 2 的端口侦听来自其实 broker 的 HA 连接。master 可以同步到 slave， slave 也可以同步到其他 slave。</p>
<p>HA 服务使用原生 NIO 实现通信， 主要有几个部分组成</p>
<ul>
<li>HAService：包装各个同步组件，主要有嵌套类来实现功能<ul>
<li>AcceptSocketService： 侦听来自其他 broker 的连接请求，accept 后创建连接对象 HAConnection</li>
<li>GroupTransferService：检查数据是否已经写到 slave</li>
<li>HAClient：连接 master，连接建立后接收 master 发送的数据并写到 commit log，然后向 master 报告自己的 maxOffset，以便控制发送速度</li>
</ul>
</li>
<li>HAConnection：显然由同步的源端使用，主要功能由嵌套类 ReadSocketService 和 WriteSocketService 实现<ul>
<li>ReadSocketService： 接收来自 slave 报告的 maxOffset，并通知 GroupTransferService</li>
<li>WriteSocketService：从 commit log 中读数据并发送给 slave</li>
</ul>
</li>
</ul>
<h4 id="master-相关代码"><a href="#master-相关代码" class="headerlink" title="master 相关代码"></a>master 相关代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HAService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  List&lt;HAConnection&gt; connectionList = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 保持所有连接</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AcceptSocketService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    AtomicLong push2SlaveMaxOffset = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">this</span>.serverSocketChannel.socket().bind(<span class="keyword">this</span>.socketAddressListen); <span class="comment">// 打开侦听端口</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 slave 已同步到的位置</span></span><br><span class="line">    <span class="comment">// 将 push2SlaveMaxOffset 设置为 offset</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyTransferSome</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// offset &gt; push2SlaveMaxOffset 才需要更新，不能更新过后变小了</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">long</span> value = <span class="keyword">this</span>.push2SlaveMaxOffset.get(); offset &gt; value; ) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> ok = <span class="keyword">this</span>.push2SlaveMaxOffset.compareAndSet(value, offset);</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">          <span class="keyword">this</span>.groupTransferService.notifyTransferSome();  <span class="comment">// ok 就通知线程</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          value = <span class="keyword">this</span>.push2SlaveMaxOffset.get(); <span class="comment">// 不 ok 继续尝试更新</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.selector.select(<span class="number">1000</span>);</span><br><span class="line">          Set&lt;SelectionKey&gt; selected = <span class="keyword">this</span>.selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (selected != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SelectionKey k : selected) &#123;</span><br><span class="line">              <span class="keyword">if</span> ((k.readyOps() &amp; SelectionKey.OP_ACCEPT) != <span class="number">0</span>) &#123; <span class="comment">// ACCEPT 事件</span></span><br><span class="line">                SocketChannel sc = ((ServerSocketChannel) k.channel()).accept();</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 创建 HAConnection</span></span><br><span class="line">                  HAConnection conn = <span class="keyword">new</span> HAConnection(HAService.<span class="keyword">this</span>, sc);</span><br><span class="line">                  conn.start();</span><br><span class="line">                  HAService.<span class="keyword">this</span>.addConnection(conn);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待数据同步到 slave</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">GroupTransferService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWaitTransfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (CommitLog.GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// req.getNextOffset() 是期望要同步到的 offset</span></span><br><span class="line">        <span class="comment">// push2SlaveMaxOffset 是已经同步到的 offset</span></span><br><span class="line">        <span class="comment">// 每过 1 秒检比较一下 push2SlaveMaxOffset 和 req.getNextOffset()，最多比较 5 次</span></span><br><span class="line">        <span class="keyword">boolean</span> transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; !transferOK &amp;&amp; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.notifyTransferObject.waitForRunning(<span class="number">1000</span>);</span><br><span class="line">            transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!transferOK) &#123;</span><br><span class="line">            log.warn(<span class="string">"transfer messsage to slave timeout, "</span> + req.getNextOffset()); <span class="comment">// 不 OK 也没办法了， 日志告警</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        req.wakeupCustomer(transferOK);  <span class="comment">// 通知等待的线程</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HAConnection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReadSocketService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">processReadEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">int</span> readSize = <span class="keyword">this</span>.socketChannel.read(<span class="keyword">this</span>.byteBufferRead);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">long</span> readOffset = <span class="keyword">this</span>.byteBufferRead.getLong(pos - <span class="number">8</span>);</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      HAConnection.<span class="keyword">this</span>.slaveAckOffset = readOffset;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新 HaService 的 push2SlaveMaxOffset</span></span><br><span class="line">      HAConnection.<span class="keyword">this</span>.haService.notifyTransferSome(HAConnection.<span class="keyword">this</span>.slaveAckOffset);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.selector.select(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">          processReadEvent();</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WriteSocketService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一次写的数据都包含 header 和 body TODO</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="slave-相关代码"><a href="#slave-相关代码" class="headerlink" title="slave 相关代码"></a>slave 相关代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HAService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收 master 发送的数据并写到 commit log</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HAClient</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.connectMaster()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isTimeToReportOffset()) &#123;</span><br><span class="line">              <span class="keyword">boolean</span> result = <span class="keyword">this</span>.reportSlaveMaxOffset(<span class="keyword">this</span>.currentReportedOffset); <span class="comment">// 向 master 报告当前的 offset，即写数据</span></span><br><span class="line">              ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.selector.select(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> ok = <span class="keyword">this</span>.processReadEvent(); <span class="comment">// 处理读到的数据</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            waitForRunning(<span class="number">1000</span> * <span class="number">5</span>); <span class="comment">// 连接不 ok 就先等着</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">processReadEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">this</span>.byteBufferRead.hasRemaining()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> readSize = <span class="keyword">this</span>.socketChannel.read(<span class="keyword">this</span>.byteBufferRead);</span><br><span class="line">          <span class="keyword">if</span> (readSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            dispatchReadRequest(); <span class="comment">// 读数据</span></span><br><span class="line">            ...</span><br><span class="line">          &#125; <span class="keyword">else</span> (readSize == <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchReadRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      HAService.<span class="keyword">this</span>.defaultMessageStore.appendToCommitLog(masterPhyOffset, bodyData); <span class="comment">// 直接 append 数据到 commit log</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="consume-queue"><a href="#consume-queue" class="headerlink" title="consume queue"></a>consume queue</h3><p>ConsumeQueue 记录消息在 CommitLog 中的位置，一个 ConsumeQueue 对象表示一个 Topic 下的一个队列。</p>
<p>ConsumeQueue 按 topic 和 队列 ID 保存在 ${storePath}/consumequeue/${topic}/${queueId} 目录下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CQ_STORE_UNIT_SIZE = <span class="number">20</span>; <span class="comment">// ConsumeQueue 中每一个条目长度是固定的 20</span></span><br><span class="line"></span><br><span class="line">  MappedFileQueue mappedFileQueue; <span class="comment">// 读写内存映射文件</span></span><br><span class="line">  String topic; <span class="comment">//  topic</span></span><br><span class="line">  <span class="keyword">int</span> queueId; <span class="comment">// 队列 id</span></span><br><span class="line">  ConsumeQueueExt consumeQueueExt; <span class="comment">// 保存额外的信息</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 写完 commit log 后会异步触发这个调用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfoWrapper</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = putMessagePositionInfo(request.getCommitLogOffset(), request.getMsgSize(), tagsCode, request.getConsumeQueueOffset());</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      <span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setLogicsMsgTimestamp(request.getStoreTimestamp());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将消息在 commit long 中的 offset 和 size 写到 consume queue</span></span><br><span class="line"><span class="comment">   * @param offset 消息在 commit log 中的逻辑位置</span></span><br><span class="line"><span class="comment">   * @param size 消息的大小</span></span><br><span class="line"><span class="comment">   * @param tagsCode 消息的 tagsCode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putMessagePositionInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> size, <span class="keyword">final</span> <span class="keyword">long</span> tagsCode, <span class="keyword">final</span> <span class="keyword">long</span> cqOffset)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.flip();</span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);</span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.putLong(offset);</span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.putInt(size);</span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.putLong(tagsCode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到对应的 MappedFile</span></span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(expectLogicOffset);</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 顺序写</span></span><br><span class="line">      <span class="keyword">return</span> mappedFile.appendMessage(<span class="keyword">this</span>.byteBufferIndex.array());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SelectMappedBufferResult <span class="title">getIndexBuffer</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mappedFileSize = <span class="keyword">this</span>.mappedFileSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 offset</span></span><br><span class="line">    <span class="keyword">long</span> offset = startIndex * CQ_STORE_UNIT_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="keyword">this</span>.getMinLogicOffset()) &#123;</span><br><span class="line">      MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.findMappedFileByOffset(offset);</span><br><span class="line">      <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        SelectMappedBufferResult result = mappedFile.selectMappedBuffer((<span class="keyword">int</span>) (offset % mappedFileSize));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>索引文件由 IndexFile 类封装读写，IndexService 负责提供服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">int</span> hashSlotNum;</span><br><span class="line">  <span class="keyword">int</span> indexNum;</span><br><span class="line">  ArrayList&lt;IndexFile&gt; indexFileList = <span class="keyword">new</span> ArrayList&lt;IndexFile&gt;();</span><br><span class="line">  ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查询 key 所表示的消息在 commit log 中的位置</span></span><br><span class="line"><span class="comment">   * begin, end 表示一个时间范围</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> QueryOffsetResult <span class="title">queryOffset</span><span class="params">(String topic, String key, <span class="keyword">int</span> maxNum, <span class="keyword">long</span> begin, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 保存消息在 commit log 中的位置， 由于一个 key 可能有多个结果，用 List 保存</span></span><br><span class="line">     List&lt;Long&gt; phyOffsets = <span class="keyword">new</span> ArrayList&lt;Long&gt;(maxNum);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">long</span> indexLastUpdateTimestamp = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">long</span> indexLastUpdatePhyoffset = <span class="number">0</span>;</span><br><span class="line">     maxNum = Math.min(maxNum, <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getMaxMsgsNumBatch());</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.readWriteLock.readLock().lock();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!<span class="keyword">this</span>.indexFileList.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.indexFileList.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 迭代每个 index file</span></span><br><span class="line">             IndexFile f = <span class="keyword">this</span>.indexFileList.get(i - <span class="number">1</span>);</span><br><span class="line">             <span class="keyword">boolean</span> lastFile = i == <span class="keyword">this</span>.indexFileList.size();</span><br><span class="line">             <span class="keyword">if</span> (lastFile) &#123;</span><br><span class="line">               indexLastUpdateTimestamp = f.getEndTimestamp();</span><br><span class="line">               indexLastUpdatePhyoffset = f.getEndPhyOffset();</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 这个 index 文件在时间范围内，在这个文件找 key</span></span><br><span class="line">             <span class="keyword">if</span> (f.isTimeMatched(begin, end)) &#123;</span><br><span class="line">               f.selectPhyOffset(phyOffsets, buildKey(topic, key), maxNum, begin, end, lastFile);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (f.getBeginTimestamp() &lt; begin) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (phyOffsets.size() &gt;= maxNum) &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         log.error(<span class="string">"queryMsg exception"</span>, e);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.readWriteLock.readLock().unlock();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> QueryOffsetResult(phyOffsets, indexLastUpdateTimestamp, indexLastUpdatePhyoffset);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 写完 commit log 后会异步触发这个调用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildIndex</span><span class="params">(DispatchRequest req)</span> </span>&#123;</span><br><span class="line">    IndexFile indexFile = retryGetAndCreateIndexFile();</span><br><span class="line">    <span class="keyword">if</span> (indexFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">long</span> endPhyOffset = indexFile.getEndPhyOffset();</span><br><span class="line">      DispatchRequest msg = req;</span><br><span class="line">      String topic = msg.getTopic();</span><br><span class="line">      String keys = msg.getKeys();</span><br><span class="line">      <span class="keyword">if</span> (msg.getCommitLogOffset() &lt; endPhyOffset) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 事务控制有消息不索引</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());</span><br><span class="line">      <span class="keyword">switch</span> (tranType) &#123;</span><br><span class="line">          <span class="keyword">case</span> MessageSysFlag.TRANSACTION_NOT_TYPE:</span><br><span class="line">          <span class="keyword">case</span> MessageSysFlag.TRANSACTION_PREPARED_TYPE:</span><br><span class="line">          <span class="keyword">case</span> MessageSysFlag.TRANSACTION_COMMIT_TYPE:</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (req.getUniqKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有 uniqkey 就用 uniqkey 写索引</span></span><br><span class="line">        indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey())); <span class="comment">// buildKey -&gt; topic + "#" + key</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">          log.error(<span class="string">"putKey error commitlog &#123;&#125; uniqkey &#123;&#125;"</span>, req.getCommitLogOffset(), req.getUniqKey());</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (keys != <span class="keyword">null</span> &amp;&amp; keys.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        String[] keyset = keys.split(MessageConst.KEY_SEPARATOR); <span class="comment">//  KEY_SEPARATOR 是空格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keyset.length; i++) &#123;</span><br><span class="line">          String key = keyset[i];</span><br><span class="line">          <span class="keyword">if</span> (key.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每个 key 写一条索引</span></span><br><span class="line">            indexFile = putKey(indexFile, msg, buildKey(topic, key));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (indexFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">              log.error(<span class="string">"putKey error commitlog &#123;&#125; uniqkey &#123;&#125;"</span>, req.getCommitLogOffset(), req.getUniqKey());</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.error(<span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写索引</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> IndexFile <span class="title">putKey</span><span class="params">(IndexFile indexFile, DispatchRequest msg, String idxKey)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写成功为止</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">boolean</span> ok = indexFile.putKey(idxKey, msg.getCommitLogOffset(), msg.getStoreTimestamp()); !ok; ) &#123;</span><br><span class="line">      log.warn(<span class="string">"Index file ["</span> + indexFile.getFileName() + <span class="string">"] is full, trying to create another one"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 写满磁盘了</span></span><br><span class="line">      indexFile = retryGetAndCreateIndexFile();</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == indexFile) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ok = indexFile.putKey(idxKey, msg.getCommitLogOffset(), msg.getStoreTimestamp());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> indexFile;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexFile</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> hashSlotSize = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> indexSize = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">int</span> invalidIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> hashSlotNum;  <span class="comment">// 槽的最大数量</span></span><br><span class="line">  <span class="keyword">int</span> indexNum; <span class="comment">// 索引最大数量</span></span><br><span class="line"></span><br><span class="line">  MappedFile mappedFile;</span><br><span class="line">  FileChannel fileChannel;</span><br><span class="line">  MappedByteBuffer mappedByteBuffer;</span><br><span class="line">  IndexHeader indexHeader; <span class="comment">// 索引文件头</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从索引文件查出一个索引</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectPhyOffset</span><span class="params">(<span class="keyword">final</span> List&lt;Long&gt; phyOffsets, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">int</span> maxNum, <span class="keyword">final</span> <span class="keyword">long</span> begin, <span class="keyword">final</span> <span class="keyword">long</span> end, <span class="keyword">boolean</span> lock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mappedFile.hold()) &#123; <span class="comment">// hold 住</span></span><br><span class="line">      <span class="keyword">int</span> keyHash = indexKeyHashMethod(key);</span><br><span class="line">      <span class="keyword">int</span> slotPos = keyHash % <span class="keyword">this</span>.hashSlotNum;</span><br><span class="line">      <span class="keyword">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize; <span class="comment">// 计算出槽的位置</span></span><br><span class="line"></span><br><span class="line">      FileLock fileLock = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> slotValue = <span class="keyword">this</span>.mappedByteBuffer.getInt(absSlotPos); <span class="comment">// 读出槽的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="keyword">this</span>.indexHeader.getIndexCount() || <span class="keyword">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123; <span class="comment">// 不合法的值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> nextIndexToRead = slotValue; ; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (phyOffsets.size() &gt;= maxNum) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> absIndexPos = IndexHeader.INDEX_HEADER_SIZE + <span class="keyword">this</span>.hashSlotNum * hashSlotSize + nextIndexToRead * indexSize; <span class="comment">// 计算索引的位置</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读出索引的信息</span></span><br><span class="line">            <span class="keyword">int</span> keyHashRead = <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos);</span><br><span class="line">            <span class="keyword">long</span> phyOffsetRead = <span class="keyword">this</span>.mappedByteBuffer.getLong(absIndexPos + <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">long</span> timeDiff = (<span class="keyword">long</span>) <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">int</span> prevIndexRead = <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>); <span class="comment">// 这是前一个索引的位置信息</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            timeDiff *= <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> timeRead = <span class="keyword">this</span>.indexHeader.getBeginTimestamp() + timeDiff;</span><br><span class="line">            <span class="keyword">boolean</span> timeMatched = (timeRead &gt;= begin) &amp;&amp; (timeRead &lt;= end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存结果</span></span><br><span class="line">            <span class="keyword">if</span> (keyHash == keyHashRead &amp;&amp; timeMatched) &#123;</span><br><span class="line">              phyOffsets.add(phyOffsetRead);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (prevIndexRead &lt;= invalidIndex || prevIndexRead &gt; <span class="keyword">this</span>.indexHeader.getIndexCount() || prevIndexRead == nextIndexToRead || timeRead &lt; begin) &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nextIndexToRead = prevIndexRead; <span class="comment">// 下一轮循环</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"selectPhyOffset exception "</span>, e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            fileLock.release();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Failed to release the lock"</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.mappedFile.release();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将索引写到索引文件</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putKey</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">long</span> phyOffset, <span class="keyword">final</span> <span class="keyword">long</span> storeTimestamp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一个索引文件的索引数据有限，要检查容量</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt; <span class="keyword">this</span>.indexNum) &#123;</span><br><span class="line">      <span class="keyword">int</span> keyHash = indexKeyHashMethod(key); <span class="comment">// 计算散列，用的是 String.hashCode</span></span><br><span class="line">      <span class="keyword">int</span> slotPos = keyHash % <span class="keyword">this</span>.hashSlotNum; <span class="comment">// 再用计算槽的位置</span></span><br><span class="line">      <span class="keyword">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize; <span class="comment">// 槽的文件中的绝对位置</span></span><br><span class="line"></span><br><span class="line">      FileLock fileLock = <span class="keyword">null</span>; <span class="comment">//  没用到的代码，估计是遗留的</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读槽值</span></span><br><span class="line">        <span class="keyword">int</span> slotValue = <span class="keyword">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">        <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()) &#123;</span><br><span class="line">          slotValue = invalidIndex;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> timeDiff = storeTimestamp - <span class="keyword">this</span>.indexHeader.getBeginTimestamp();</span><br><span class="line"></span><br><span class="line">        timeDiff = timeDiff / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getBeginTimestamp() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          timeDiff = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">          timeDiff = Integer.MAX_VALUE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          timeDiff = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算索引的位置</span></span><br><span class="line">        <span class="comment">// 文件头 + 槽最大数（常量） * 槽大小（常量） + 目前索引数 * 索引大小（常量）</span></span><br><span class="line">        <span class="keyword">int</span> absIndexPos = IndexHeader.INDEX_HEADER_SIZE + <span class="keyword">this</span>.hashSlotNum * hashSlotSize + <span class="keyword">this</span>.indexHeader.getIndexCount() * indexSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写索引，位置是 absIndexPos，所以索引是顺序写的</span></span><br><span class="line">        <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos, keyHash);</span><br><span class="line">        <span class="keyword">this</span>.mappedByteBuffer.putLong(absIndexPos + <span class="number">4</span>, phyOffset);</span><br><span class="line">        <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>, (<span class="keyword">int</span>) timeDiff);</span><br><span class="line">        <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>, slotValue);  <span class="comment">// 写前一个槽值，这样就构成一个链表，解决键冲突</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写槽，位置是 absSlotPos，值是写索引前的索引数量</span></span><br><span class="line">        <span class="keyword">this</span>.mappedByteBuffer.putInt(absSlotPos, <span class="keyword">this</span>.indexHeader.getIndexCount());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.indexHeader.setBeginPhyOffset(phyOffset);</span><br><span class="line">          <span class="keyword">this</span>.indexHeader.setBeginTimestamp(storeTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新索引文件头</span></span><br><span class="line">        <span class="keyword">this</span>.indexHeader.incHashSlotCount();</span><br><span class="line">        <span class="keyword">this</span>.indexHeader.incIndexCount(); <span class="comment">// 写完再 + 1</span></span><br><span class="line">        <span class="keyword">this</span>.indexHeader.setEndPhyOffset(phyOffset);</span><br><span class="line">        <span class="keyword">this</span>.indexHeader.setEndTimestamp(storeTimestamp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"putKey exception, Key: "</span> + key + <span class="string">" KeyHashCode: "</span> + key.hashCode(), e);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            fileLock.release();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"Failed to release the lock"</span>, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.warn(<span class="string">"Over index file capacity: index count = "</span> + <span class="keyword">this</span>.indexHeader.getIndexCount() + <span class="string">"; index max num = "</span> + <span class="keyword">this</span>.indexNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="check-point-与文件完整性检查"><a href="#check-point-与文件完整性检查" class="headerlink" title="check point 与文件完整性检查"></a>check point 与文件完整性检查</h3><h4 id="文件-checkpoint"><a href="#文件-checkpoint" class="headerlink" title="文件 checkpoint"></a>文件 checkpoint</h4><p>checkpoint 文件保存在 ${storePath}/checkpoint 中，由 StoreCheckpoint 类负责读写。</p>
<p>checkpoint 文件只保存 3 个值，分别是 physicMsgTimestamp，logicsMsgTimestamp，indexMsgTimestamp</p>
<p>physicMsgTimestamp 表示 commit log 中最后一条有效消息的存储时间（落盘时间）</p>
<p>logicsMsgTimestamp 表示 consume queue 中最后一条有效消息的存储时间（逻辑位置）</p>
<p>indexMsgTimestamp 表示索引文件中，最新的消息的索引时间。每个索引文件都有一个 daemon 线程 负责 flush， flush 的时候会设置 check point。</p>
<h4 id="从文件恢复到对象"><a href="#从文件恢复到对象" class="headerlink" title="从文件恢复到对象"></a>从文件恢复到对象</h4><p>DefaultMessageStore 启动后，会生成 ${storePath}/abort 文件，当 DefaultMessageStore 正常退出时， 会删除 abort。所以，如果 abort 文件存在，则说明前一次是异常退出，如果文件不存在，则说明前一次是正常退出。</p>
<p>CommitLog 对象的恢复过程，主要是恢复 mappedFileQueue 对象的 flushedWhere， committedWhere 成员。</p>
<p>首先搜索 ${storePath}/commitlog 目录，将每个文件生成 MappedFIle 对象保存到 MappedFileQueue</p>
<ul>
<li>如果是正常退出，那么从倒数第 3 个 commit log 文件开始恢复。检查每条消息，找到最后的写入位置然后更新 mappedFileQueue 对象的成员</li>
<li>如果是非正常退出，由尾部开始往前检查 commit log 文件，如果文件第一条消息存储时间比 checkpoint 保存的小，就从这个文件开始做恢复。循环检查每条消息，更新 mappedFileQueue 对象的成员</li>
</ul>
<p>ConsumeQueue 的恢复类似</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/阅读笔记/" rel="tag"># 阅读笔记</a>
          
            <a href="/tags/rocketmq/" rel="tag"># rocketmq</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/04/source-note-rocket-mq-name/" rel="next" title="【阅读笔记】rocketmq 命名服务 namesrv （三）">
                <i class="fa fa-chevron-left"></i> 【阅读笔记】rocketmq 命名服务 namesrv （三）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/08/source-note-rocket-mq-default-store/" rel="prev" title="【阅读笔记】rocketmq 消息存储服务 （五）">
                【阅读笔记】rocketmq 消息存储服务 （五） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Deer</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">27</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息存储的层次结构"><span class="nav-number">2.</span> <span class="nav-text">消息存储的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CommitLog-格式"><span class="nav-number">2.1.</span> <span class="nav-text">CommitLog 格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConsumeQueue"><span class="nav-number">2.2.</span> <span class="nav-text">ConsumeQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Index"><span class="nav-number">2.3.</span> <span class="nav-text">Index</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息存储的底层技术"><span class="nav-number">3.</span> <span class="nav-text">消息存储的底层技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存映射文件"><span class="nav-number">3.1.</span> <span class="nav-text">内存映射文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PageCache-以及文件预热"><span class="nav-number">3.2.</span> <span class="nav-text">PageCache 以及文件预热</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LibC-系统调用"><span class="nav-number">3.3.</span> <span class="nav-text">LibC 系统调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消息存储的功能实现"><span class="nav-number">4.</span> <span class="nav-text">消息存储的功能实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MappedFile-amp-MappedFileQueue"><span class="nav-number">4.1.</span> <span class="nav-text">MappedFile &amp; MappedFileQueue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#commit-log"><span class="nav-number">4.2.</span> <span class="nav-text">commit log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步刷盘-VS-异步刷盘"><span class="nav-number">4.3.</span> <span class="nav-text">同步刷盘 VS 异步刷盘</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HA（同步双写-VS-异步复制）"><span class="nav-number">4.4.</span> <span class="nav-text">HA（同步双写 VS 异步复制）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HA"><span class="nav-number">4.5.</span> <span class="nav-text">HA</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#master-相关代码"><span class="nav-number">4.5.1.</span> <span class="nav-text">master 相关代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slave-相关代码"><span class="nav-number">4.5.2.</span> <span class="nav-text">slave 相关代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#consume-queue"><span class="nav-number">4.6.</span> <span class="nav-text">consume queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#index"><span class="nav-number">4.7.</span> <span class="nav-text">index</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#check-point-与文件完整性检查"><span class="nav-number">4.8.</span> <span class="nav-text">check point 与文件完整性检查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件-checkpoint"><span class="nav-number">4.8.1.</span> <span class="nav-text">文件 checkpoint</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从文件恢复到对象"><span class="nav-number">4.8.2.</span> <span class="nav-text">从文件恢复到对象</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Deer</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
