<!DOCTYPE html>













<html class="theme-next gemini" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">





















  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=sans-serif:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext">
  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="分析 rocketmq 的如何实现消息的存储">
<meta name="keywords" content="rocketmq">
<meta property="og:type" content="article">
<meta property="og:title" content="【阅读笔记】rocketmq 消息存储 （四）">
<meta property="og:url" content="http://yoursite.com/2019/05/05/source-note-rocket-mq-store/index.html">
<meta property="og:site_name" content="Deer&#39;s blog">
<meta property="og:description" content="分析 rocketmq 的如何实现消息的存储">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/05/05/source-note-rocket-mq-store/rocketmq_store_struct.png">
<meta property="og:image" content="http://yoursite.com/2019/05/05/source-note-rocket-mq-store/rocketmq_store.png">
<meta property="og:updated_time" content="2019-09-21T13:48:53.954Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【阅读笔记】rocketmq 消息存储 （四）">
<meta name="twitter:description" content="分析 rocketmq 的如何实现消息的存储">
<meta name="twitter:image" content="http://yoursite.com/2019/05/05/source-note-rocket-mq-store/rocketmq_store_struct.png">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/05/05/source-note-rocket-mq-store/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>【阅读笔记】rocketmq 消息存储 （四） | Deer's blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Deer's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/05/source-note-rocket-mq-store/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Deer">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deer's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">【阅读笔记】rocketmq 消息存储 （四）

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-05 21:15:04" itemprop="dateCreated datePublished" datetime="2019-05-05T21:15:04+08:00">2019-05-05</time>
            

            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>分析 rocketmq 的如何实现消息的存储</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>store 模块定义了 rocketmq 如何将消息存储在文件系统。只要消息被刷盘持久化至磁盘文件中，那么 Producer 发送的消息就不会丢失，而 Consumer 也就肯定有机会去消费这条消息。</p>
<h1 id="消息存储的层次结构"><a href="#消息存储的层次结构" class="headerlink" title="消息存储的层次结构"></a>消息存储的层次结构</h1><p><img src="/2019/05/05/source-note-rocket-mq-store/rocketmq_store_struct.png" alt="rocketmq 存储结构"></p>
<p>rocketmq 文件存储模型层次结构如上图所示，概念上可以分为 5 层：</p>
<ol>
<li>rocketmq 业务处理器层，是 Broker 端对消息进行读取和写入的业务逻辑入口</li>
<li>rocketmq 数据存储组件层，主要是 rocketmq 的存储核心类 DefaultMessageStore，为 rocketmq 消息数据文件的访问入口</li>
<li>rocketmq 存储<strong><em>逻辑对象层</em></strong>，主要是三个模型类 IndexFile、ConsumerQueue 和 CommitLog</li>
<li>封装的文件内存映射层，采用 NIO 中的 MappedByteBuffer 和 FileChannel 完成数据文件读写</li>
<li>磁盘存储层，部署 rocketmq 服务器所用的磁盘</li>
</ol>
<p><img src="/2019/05/05/source-note-rocket-mq-store/rocketmq_store.png" alt="rocketmq 消息存储格式"></p>
<p>存储逻辑对象层说明：</p>
<ol>
<li>单个 broker 的所有消息都保存在 commit log 文件</li>
<li>生产者发送消息到 broker，broker 先写到 commit log</li>
<li>将消息在 commit log 在的位置记录到 consume queue（逻辑消费队列）<br>consume queue 维护了 3 个变量：<br>minOffset 表示 consume queue 中是早一个消息的逻辑下标<br>consumerOffset 表示目前消费到的逻辑下标（保存在 consumerOffset），<br>maxOffset 表示新消息在 consume queue 中的逻辑下标</li>
<li>消费者消费消息时，是按顺序从 consume queue 得到消息的存储位置，然后到 commit log 中取消息内容</li>
<li>consume queue 按 Topic 组合，每个 Topic 下有多个 consume queue</li>
<li>index 文件提供快速查找消息的方法，而且通过 index 文件来找消息不影响消息的消费</li>
</ol>
<p>对于 consume queue， 采用顺序读写，速度较快，而 commit log 写入时是顺序写入，读取进是随机读取，读的效率偏低。<br>消费一条消息需要先读 consume queue 再读 commit log，有一定的开销</p>
<h2 id="CommitLog-格式"><a href="#CommitLog-格式" class="headerlink" title="CommitLog 格式"></a>CommitLog 格式</h2><p>用于保存消息，默认保存在 store/commitlog 目录下，每个文件都是 1GB，按顺序保存消息。</p>
<p>文件名每个都是 20 位，左边补0。第一个文件文件名是 00000000000000000000，起始位置的逻辑位置是 0，即偏移量是0。当第一个文件写满后，第二个文件文件名是 00000000001073741824（1G），起始位置的<strong>逻辑位置</strong>是 1073741824，即当要查找 commitLog 第 1073741825 的位置时，就读第二个文件的第 1 个字节，由此类推。</p>
<p>CommitLog 的内部类 MessageExtBatchEncoder 定义怎么将消息体变成字节流，DefaultAppendMessageCallback 的 doAppend 定义怎么将流读到消息体。一个消息包括以下内容：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>字段简称</th>
<th>字段大小（字节），类型</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>TOTALSIZE</td>
<td>4，Integer</td>
<td>消息总长度</td>
</tr>
<tr>
<td></td>
<td>MAGICCODE</td>
<td>4，Integer</td>
<td>魔术数，CommitLog. MESSAGE_MAGIC_CODE</td>
</tr>
<tr>
<td></td>
<td>BODYCRC</td>
<td>4，Integer</td>
<td>消息体CRC</td>
</tr>
<tr>
<td></td>
<td>QUEUEID</td>
<td>4，Integer</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>FLAG</td>
<td>4，Integer</td>
<td></td>
</tr>
<tr>
<td></td>
<td>QUEUEOFFSET</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td></td>
<td>PHYSICALOFFSET</td>
<td>8，Long</td>
<td>消息在commitLog中的物理起始地址偏移量</td>
</tr>
<tr>
<td></td>
<td>SYSFLAG</td>
<td>4，Integer</td>
<td></td>
</tr>
<tr>
<td></td>
<td>BORNTIMESTAMP</td>
<td>8，Long</td>
<td>消息产生时间戳</td>
</tr>
<tr>
<td>10</td>
<td>BORNHOST</td>
<td>8，byte buffer</td>
<td>消息生产者地址, IP:Port</td>
</tr>
<tr>
<td></td>
<td>STORETIMESTAMP</td>
<td>8，Long</td>
<td>消息在 broker 的时间戳</td>
</tr>
<tr>
<td></td>
<td>STOREHOSTADDRESS</td>
<td>8，byte</td>
<td>buffer    消息存储到broker的地址，IP:Port</td>
</tr>
<tr>
<td></td>
<td>RECONSUMETIMES</td>
<td>4，Integer</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Prepared Transaction Offset</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>BODY LENGTH</td>
<td>4，Integer</td>
<td>BODY 的长度</td>
</tr>
<tr>
<td></td>
<td>BODY</td>
<td>BODY LENGTH</td>
<td></td>
</tr>
<tr>
<td></td>
<td>TOPIC LENGTH</td>
<td>1，byte</td>
<td>TOPIC 的长度</td>
</tr>
<tr>
<td></td>
<td>TOPIC</td>
<td>TOPIC LENGTH</td>
<td></td>
</tr>
<tr>
<td></td>
<td>PROPERTIES LENGTH</td>
<td>2，Short</td>
<td>PROPERTIES 的长度</td>
</tr>
<tr>
<td>20</td>
<td>PROPERTIES</td>
<td>PROPERTIES LENGTH</td>
<td>消息的属性</td>
</tr>
</tbody>
</table>
<h2 id="ConsumeQueue"><a href="#ConsumeQueue" class="headerlink" title="ConsumeQueue"></a>ConsumeQueue</h2><p>默认保存在 store/consumequeue/${Topic}/${queueid} 目录下，每个文件都是 600 万字节（5.7MB）</p>
<p>文件名每个都是 20 位，左边补 0，第一个文件文件名是 00000000000000000000， 与 CommitLog 的规则类似</p>
<p>每个 entry 包含如下内容：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>字段简称</th>
<th>字段大小（字节），类型</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>offset</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td></td>
<td>size</td>
<td>4，Integer</td>
<td></td>
</tr>
<tr>
<td></td>
<td>tagsCode</td>
<td>8，Long</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>记录某个 key 在 commit log 中的位置。索引文件由头，hashSlot，和 index 组成。</p>
<p>文件头包括有如下字段</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>字段简称</th>
<th>字段大小（字节），类型</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>beginTimestamp</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td></td>
<td>endTimestamp</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td></td>
<td>beginPhyOffset</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td></td>
<td>endPhyOffset</td>
<td>8，Long</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>hashSlotCount</td>
<td>4，Integer</td>
<td></td>
</tr>
<tr>
<td></td>
<td>indexCount</td>
<td>4，Integer</td>
<td>索引的数量</td>
</tr>
</tbody>
</table>
<p>一个 hashSlot 占 4 字节，一共有 hashSlotNum 个（在 MessageStoreConfig.maxHashSlotNum 配置项定义）。一个 hashSlot 的值表示这个 hash 值的 index 的下标<br>index 有如下字段</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>字段简称</th>
<th>字段大小（字节），类型</th>
<th>字段含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>keyHash</td>
<td>4，Integer</td>
<td>散列值</td>
</tr>
<tr>
<td></td>
<td>phyOffset</td>
<td>8，Long</td>
<td><strong>消息 在 commit log 中的位置</strong></td>
</tr>
<tr>
<td></td>
<td>timeDiff</td>
<td>4，Integer</td>
<td>storeTimestamp 到 beginTimestamp 的差</td>
</tr>
<tr>
<td></td>
<td>slotValue</td>
<td>4，Integer</td>
<td>hashSlot 的旧值，表示同样 hash 值的 index 的下标，相当于链表的 pre 指针。用拉链法解决 hash 冲突</td>
</tr>
</tbody>
</table>
<h1 id="消息存储的底层技术"><a href="#消息存储的底层技术" class="headerlink" title="消息存储的底层技术"></a>消息存储的底层技术</h1><h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>将文件内容映射到内存中，这里的映射是<strong>硬盘上文件</strong>的位置与进程<strong>逻辑地址空间</strong>的一一对应，然后文件的读写通过访问这段内存实现，这样就减少了 read / write 等系统调用。</p>
<p>使用 read / write 等系统调用，读操作的话操作系统先将文件的内存加载到<strong>内核</strong>空间，再复制到<strong>用户进程</strong>空间；写操作的话会先将<strong>用户进程</strong>空间复制到<strong>内核</strong>空间再写入磁盘。内存映射文件技术减少了这些中间操作，从而提升效率。</p>
<p>java 中通过 FileChannel 的 map 成员方法可以打开内存映射文件</p>
<h2 id="PageCache-以及文件预热"><a href="#PageCache-以及文件预热" class="headerlink" title="PageCache 以及文件预热"></a>PageCache 以及文件预热</h2><p>系统的所有文件 I/O 请求，操作系统都是通过 page cache 机制实现的。对于操作系统来说，磁盘文件都是由一系列的数据块顺序组成，数据块的大小由操作系统本身而决定，x86 的 linux 中一个标准页面大小是 4KB。</p>
<p>操作系统内核在处理文件 I/O 请求时，首先到 page cache 中查找（page cache 中的每一个数据块都设置了文件以及偏移量地址信息），如果未命中，则启动磁盘 I/O，将磁盘文件中的数据块加载到 page cache 中的一个空闲块，然后再 copy 到用户缓冲区中。</p>
<p>page cache 本身也会对数据文件进行预读取，对于每个文件的第一个读请求操作，系统在读入所请求页面的同时会读入紧随其后的少数几个页面。<strong>因此，想要提高 page cache 的命中率（尽量让访问的页在物理内存中）</strong>，从硬件的角度来说肯定是物理内存越大越好。从操作系统层面来说，访问 page cache 时，即使只访问 1k 的消息，系统也会提前预读取更多的数据，在下次读取消息时, 就很可能可以命中内存。</p>
<p>每当创建一个新的 commit log 内存映射文件，rocketmq 会每隔 4k 写入一个 0，使得整个文件都会加载到内存，然后用 mlock 锁定内存。这样 commit log 的读写都会通过内存进行，可以有效提高消息的 I/O 效率。</p>
<h2 id="LibC-系统调用"><a href="#LibC-系统调用" class="headerlink" title="LibC 系统调用"></a>LibC 系统调用</h2><p>利用 JNA 加载  C Runtime 库，并调用其中的 API</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LibC</span> <span class="keyword">extends</span> <span class="title">Library</span> </span>&#123;</span><br><span class="line">    LibC INSTANCE = (LibC) Native.loadLibrary(Platform.isWindows() ? <span class="string">"msvcrt"</span> : <span class="string">"c"</span>, LibC.class);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁定系统物理内存，防止被系统换出</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mlock</span><span class="params">(Pointer var1, NativeLong var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">munlock</span><span class="params">(Pointer var1, NativeLong var2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉内核如何使用某些映射或共享内存区域</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">madvise</span><span class="params">(Pointer var1, NativeLong var2, <span class="keyword">int</span> var3)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方式</span></span><br><span class="line">LibC.INSTANCE.mlock(var1, var2);</span><br></pre></td></tr></table></figure>
<h1 id="消息存储的功能实现"><a href="#消息存储的功能实现" class="headerlink" title="消息存储的功能实现"></a>消息存储的功能实现</h1><h2 id="MappedFile-amp-MappedFileQueue"><a href="#MappedFile-amp-MappedFileQueue" class="headerlink" title="MappedFile &amp; MappedFileQueue"></a>MappedFile &amp; MappedFileQueue</h2><p>MappedFile 操作内存映射文件，负责用内存映射的方式读写文件。 MappedFile 继承了 ReferenceResource，ReferenceResource 采用引用计数的方式管理资源。</p>
<p>MappedFile 有两种工作方式，由 MessageStoreConfig.isTransientStorePoolEnable 配置项控制</p>
<p>当 MessageStoreConfig.isTransientStorePoolEnable 为 true 时，MappedFile 在 init 会传入 TransientStorePool 对象，并从中取出 ByteBuffer  给 <strong>writeBuffer</strong> 成员赋值；当 MessageStoreConfig.isTransientStorePoolEnable 为 false 时则不传入</p>
<p>当 writeBuffer 非空时，就使用 writeBuffer 进行读写，否则使用 mappedByteBuffer 进行读写</p>
<p>主要区别是 flush 和 commit 方法不同:  </p>
<ol>
<li>使用 writeBuffer，读写操作其实是先写到另外的 byteBuffer，而不是文件映射到的  mappedByteBuffer<br> commit 将 writeBuffer 写入 fileChannel<br> flush 方法调用 fileChannel 的 force，强制将 fileChannel 所有更新写入存储设备，因为这时不使用 mappedByteBuffer 读写，所以不用管 mappedByteBuffer  </li>
<li>使用 mappedByteBuffer<br> commit 方法什么都不做<br> flush 方法调用 mappedByteBuffer 的 force，强制 mappedByteBuffer 的所有更新写入到存储设备  </li>
</ol>
<p>因为 MappedFile 总是多个出现，例如 commit log 就由多个文件组成，所以用列表组织起来，并提供服务。所有对 MappedFile 的操作其实都要经过 MappedFileQueue。</p>
<p>MappedFileQueue 的主要成员有<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFileQueue</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  String storePath; <span class="comment">// 文件保存路径</span></span><br><span class="line"></span><br><span class="line">  CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles; <span class="comment">// 保存多个 MappedFile</span></span><br><span class="line"></span><br><span class="line">  AllocateMappedFileService allocateMappedFileService; <span class="comment">// 用于创建新的 MappedFile 并给 MappedFile 预热</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> flushedWhere; <span class="comment">// 记录已经 flush 的位置</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> committedWhere; <span class="comment">// 记录已经 commit 的位置</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载 storePath 下的所有文件</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 startOffset 位置的 MappedFIle 对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MappedFile <span class="title">getLastMappedFile</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startOffset, <span class="keyword">boolean</span> needCreate)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 mappedFiles 中最后一个 MappedFile 对象</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MappedFile <span class="title">getLastMappedFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MappedFile mappedFileLast = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于 size 之后可能被其他线程修改，所以要循环读取，并 catch IndexOutOfBoundsException 异常</span></span><br><span class="line">        <span class="keyword">while</span> (!<span class="keyword">this</span>.mappedFiles.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mappedFileLast = <span class="keyword">this</span>.mappedFiles.get(<span class="keyword">this</span>.mappedFiles.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">                <span class="comment">//continue;</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"getLastMappedFile has exception."</span>, e);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mappedFileLast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除过期的文件，防止过多占用空间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">truncateDirtyFiles</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="commit-log"><a href="#commit-log" class="headerlink" title="commit log"></a>commit log</h2><p>CommitLog 类实现了对 commit log 文件的读写。 CommitLog 文件保存在 ${storePath}/commitlog/ 目录下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommitLog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  MappedFileQueue mappedFileQueue; <span class="comment">// 读写 mappedFiles</span></span><br><span class="line"></span><br><span class="line">  FlushCommitLogService flushCommitLogService; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  FlushCommitLogService commitLogService; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">  AppendMessageCallback appendMessageCallback; <span class="comment">// 用于写 meesage</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读数据</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将逻辑位置 offset 后的内容读出</span></span><br><span class="line">  <span class="comment">// SelectMappedBufferResult 封装了一个 ByteBuffer，可以直接表示读出的内容，不需要做复制操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SelectMappedBufferResult <span class="title">getData</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">boolean</span> returnFirstOnNotFound)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个文件的大小</span></span><br><span class="line">    <span class="keyword">int</span> mappedFileSize = <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getMapedFileSizeCommitLog();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到 offset 所在的 MappedFile</span></span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.findMappedFileByOffset(offset, returnFirstOnNotFound);</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = (<span class="keyword">int</span>) (offset % mappedFileSize); <span class="comment">// pos 就是 offset 在 MappedFile 中的实际位置</span></span><br><span class="line">        SelectMappedBufferResult result = mappedFile.selectMappedBuffer(pos);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 顺序写消息</span></span><br><span class="line">  <span class="function">PutMessageResult <span class="title">putMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (msg.getDelayTimeLevel() &gt; <span class="number">0</span>) &#123; <span class="comment">// 处理延时投递</span></span><br><span class="line">        ...</span><br><span class="line">        topic = ScheduleMessageService.SCHEDULE_TOPIC; <span class="comment">// 先将消息写到 SCHEDULE_TOPIC_XXXX 这个 topic</span></span><br><span class="line">        queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());</span><br><span class="line">        ..</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> eclipseTimeInLock = <span class="number">0</span>;</span><br><span class="line">    MappedFile unlockMappedFile = <span class="keyword">null</span>;</span><br><span class="line">    MappedFile mappedFile = mappedFileQueue.getLastMappedFile(); <span class="comment">// 最后一个 MappedFile</span></span><br><span class="line"></span><br><span class="line">    putMessageLock.lock(); <span class="comment">// 这个锁有 ReentrantLock 和用 AtomicBoolean 实现的自旋锁两种实现，取决于配置</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 通过 appendMessageCallback 写消息</span></span><br><span class="line"><span class="comment">         appendMessage 为 appendMessageCallback 提供一个 byteBuffer 参数</span></span><br><span class="line"><span class="comment">         这个 byteBuffer 决定了写到哪个内存（writeBuffer or mappedByteBuffer)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         appendMessageCallback 使用 DefaultAppendMessageCallback 实现，它前面提到的格式将消息写到 byteBuffer</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      result = mappedFile.appendMessage(msg, appendMessageCallback);</span><br><span class="line">      <span class="keyword">switch</span> (result.getStatus()) &#123;</span><br><span class="line">        ...  构造 PutMessageResult</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      eclipseTimeInLock = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;</span><br><span class="line">      beginTimeInLock = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      putMessageLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ..</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理刷盘</span></span><br><span class="line">    handleDiskFlush(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 HA</span></span><br><span class="line">    handleHA(result, putMessageResult, msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> putMessageResult;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写批量消息与写单个消息类似</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接写数据，这是 slave 写数据时用的</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">appendData</span><span class="params">(<span class="keyword">long</span> startOffset, <span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">    putMessageLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(startOffset);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> mappedFile.appendMessage(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      putMessageLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="同步刷盘-VS-异步刷盘"><a href="#同步刷盘-VS-异步刷盘" class="headerlink" title="同步刷盘 VS 异步刷盘"></a>同步刷盘 VS 异步刷盘</h2><p>handleDiskFlush 处理磁盘的刷新。当使用同步方式时，commit log 写到磁盘后，putMessage 才返回；当使用异步方式时，commit log 写到内存就返回，由专门的线程将内存刷新到磁盘。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 所有的刷盘动作，都是调用 MappedFileQueue 的 flush 方法实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDiskFlush</span><span class="params">(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Synchronization flush</span></span><br><span class="line">    <span class="keyword">if</span> (FlushDiskType.SYNC_FLUSH == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getFlushDiskType()) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> GroupCommitService service = (GroupCommitService) <span class="keyword">this</span>.flushCommitLogService;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123; <span class="comment">// 消息可以加一个属性，使得不用同步方式刷盘</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同步方式刷盘，创建一个刷盘的请求，然后等待刷盘完成</span></span><br><span class="line">        <span class="comment">// 使用同步方式时，flushCommitLogService 是 GroupCommitService 类对象        </span></span><br><span class="line">        GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GroupCommitService 有两个队列，requestsWrite 和 requestsRead</span></span><br><span class="line">        <span class="comment">// putRequest 会将  request 添加到 requestsWrite 并使用线程开始运行</span></span><br><span class="line">        service.putRequest(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// GroupCommitRequest 内部有一个 CountDownLatch， waitForFlush 方法调用 countDownLatch.await</span></span><br><span class="line">        <span class="keyword">boolean</span> flushOK = request.waitForFlush(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">          ... <span class="comment">// 报错</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        service.wakeup(); <span class="comment">// 仅唤醒线程</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Asynchronous flush</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 仅唤醒线程</span></span><br><span class="line">      <span class="comment">// 如果使用 isTransientStorePoolEnable 的话，还需要 commit 再 flush，所以这里需要使用两个不同的线程实现刷盘</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().isTransientStorePoolEnable()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在异步刷盘方式中，flushCommitLogService 是 FlushRealTimeService 类对象</span></span><br><span class="line">        <span class="comment">// 这个线程每隔固定时间调用一次  mappedFileQueue.flush</span></span><br><span class="line">        flushCommitLogService.wakeup();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CommitRealTimeService 每隔固定时间调用一次 mappedFileQueue.commit</span></span><br><span class="line">        <span class="comment">// 然后唤醒 flushCommitLogService，让这个线程做 flush</span></span><br><span class="line">        commitLogService.wakeup();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">GroupCommitService</span> <span class="keyword">extends</span> <span class="title">FlushCommitLogService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">for</span> (GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">            ...</span><br><span class="line">            CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>); <span class="comment">// 刷盘，如果 req 中要求刷盘的位置已经刷过，就不用刷</span></span><br><span class="line">            ...</span><br><span class="line">            req.wakeupCustomer(flushOK); <span class="comment">// 通知到等待 req 的线程</span></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">          requestsRead.clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          CommitLog.<span class="keyword">this</span>.mappedFileQueue.flush(<span class="number">0</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">this</span>.waitForRunning(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">this</span>.doCommit();</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      doCommit(); <span class="comment">// 正常的循环退出后还要再刷盘一次</span></span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="HA（同步双写-VS-异步复制）"><a href="#HA（同步双写-VS-异步复制）" class="headerlink" title="HA（同步双写 VS 异步复制）"></a>HA（同步双写 VS 异步复制）</h2><p>handleHA 实现 master 到 slave 的同步双写，如果是采用异步复制的方法，这个方法会直接返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleHA</span><span class="params">(AppendMessageResult result, PutMessageResult putMessageResult, MessageExt messageExt)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是不是同步双写</span></span><br><span class="line">  <span class="keyword">if</span> (BrokerRole.SYNC_MASTER == <span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HAService 有个嵌套类 GroupTransferService</span></span><br><span class="line">    <span class="comment">// GroupTransferService 检查是否已经写到 slave，写完成就通知正在等待的线程</span></span><br><span class="line">    <span class="comment">// 同步双写仍然是通过 slave 往 master 读 commit log 来实现，这里的同步只不过是在 putMessage 中增加了等待，确保同步已经完成</span></span><br><span class="line">    HAService service = <span class="keyword">this</span>.defaultMessageStore.getHaService();</span><br><span class="line">    <span class="keyword">if</span> (messageExt.isWaitStoreMsgOK()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查 slave 是否连接正常，且这个 req 对 slave 来说是不是 OK 的</span></span><br><span class="line">        <span class="keyword">if</span> (service.isSlaveOK(result.getWroteOffset() + result.getWroteBytes())) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// request &amp; wait</span></span><br><span class="line">          GroupCommitRequest request = <span class="keyword">new</span> GroupCommitRequest(result.getWroteOffset() + result.getWroteBytes());</span><br><span class="line">          service.putRequest(request);</span><br><span class="line">          service.getWaitNotifyObject().wakeupAll();</span><br><span class="line">          <span class="keyword">boolean</span> flushOK = request.waitForFlush(<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig().getSyncFlushTimeout());</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (!flushOK) &#123;</span><br><span class="line">              ... 报错</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Slave problem</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          ...  报错</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步复制就直接返回</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="HA"><a href="#HA" class="headerlink" title="HA"></a>HA</h2><p>HAService 类实现了 commit log 的 master-slave 同步。broker 启动时，会打开 listen + 2 的端口侦听来自其实 broker 的 HA 连接。master 可以同步到 slave， slave 也可以同步到其他 slave。</p>
<p>HA 服务使用原生 NIO 实现通信， 主要有几个部分组成</p>
<ul>
<li>HAService：包装各个同步组件，主要有嵌套类来实现功能<ul>
<li>AcceptSocketService： 侦听来自其他 broker 的连接请求，accept 后创建连接对象 HAConnection</li>
<li>GroupTransferService：检查数据是否已经写到 slave</li>
<li>HAClient：连接 master，连接建立后接收 master 发送的数据并写到 commit log，然后向 master 报告自己的 maxOffset，以便控制发送速度</li>
</ul>
</li>
<li>HAConnection：显然由同步的源端使用，主要功能由嵌套类 ReadSocketService 和 WriteSocketService 实现<ul>
<li>ReadSocketService： 接收来自 slave 报告的 maxOffset，并通知 GroupTransferService</li>
<li>WriteSocketService：从 commit log 中读数据并发送给 slave</li>
</ul>
</li>
</ul>
<h3 id="master-相关代码"><a href="#master-相关代码" class="headerlink" title="master 相关代码"></a>master 相关代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HAService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  List&lt;HAConnection&gt; connectionList = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 保持所有连接</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AcceptSocketService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    AtomicLong push2SlaveMaxOffset = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">this</span>.serverSocketChannel.socket().bind(<span class="keyword">this</span>.socketAddressListen); <span class="comment">// 打开侦听端口</span></span><br><span class="line">      ...      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 slave 已同步到的位置</span></span><br><span class="line">    <span class="comment">// 将 push2SlaveMaxOffset 设置为 offset</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyTransferSome</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// offset &gt; push2SlaveMaxOffset 才需要更新，不能更新过后变小了</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">long</span> value = <span class="keyword">this</span>.push2SlaveMaxOffset.get(); offset &gt; value; ) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> ok = <span class="keyword">this</span>.push2SlaveMaxOffset.compareAndSet(value, offset);</span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">          <span class="keyword">this</span>.groupTransferService.notifyTransferSome();  <span class="comment">// ok 就通知线程</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          value = <span class="keyword">this</span>.push2SlaveMaxOffset.get(); <span class="comment">// 不 ok 继续尝试更新</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.selector.select(<span class="number">1000</span>);</span><br><span class="line">          Set&lt;SelectionKey&gt; selected = <span class="keyword">this</span>.selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (selected != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (SelectionKey k : selected) &#123;</span><br><span class="line">              <span class="keyword">if</span> ((k.readyOps() &amp; SelectionKey.OP_ACCEPT) != <span class="number">0</span>) &#123; <span class="comment">// ACCEPT 事件</span></span><br><span class="line">                SocketChannel sc = ((ServerSocketChannel) k.channel()).accept();</span><br><span class="line"></span><br><span class="line">                ...</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 创建 HAConnection</span></span><br><span class="line">                  HAConnection conn = <span class="keyword">new</span> HAConnection(HAService.<span class="keyword">this</span>, sc);</span><br><span class="line">                  conn.start();</span><br><span class="line">                  HAService.<span class="keyword">this</span>.addConnection(conn);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待数据同步到 slave</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">GroupTransferService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWaitTransfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (CommitLog.GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// req.getNextOffset() 是期望要同步到的 offset</span></span><br><span class="line">        <span class="comment">// push2SlaveMaxOffset 是已经同步到的 offset</span></span><br><span class="line">        <span class="comment">// 每过 1 秒检比较一下 push2SlaveMaxOffset 和 req.getNextOffset()，最多比较 5 次</span></span><br><span class="line">        <span class="keyword">boolean</span> transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; !transferOK &amp;&amp; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.notifyTransferObject.waitForRunning(<span class="number">1000</span>);</span><br><span class="line">            transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!transferOK) &#123;</span><br><span class="line">            log.warn(<span class="string">"transfer messsage to slave timeout, "</span> + req.getNextOffset()); <span class="comment">// 不 OK 也没办法了， 日志告警</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        req.wakeupCustomer(transferOK);  <span class="comment">// 通知等待的线程</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HAConnection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReadSocketService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">processReadEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">int</span> readSize = <span class="keyword">this</span>.socketChannel.read(<span class="keyword">this</span>.byteBufferRead);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">long</span> readOffset = <span class="keyword">this</span>.byteBufferRead.getLong(pos - <span class="number">8</span>);</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      HAConnection.<span class="keyword">this</span>.slaveAckOffset = readOffset;</span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更新 HaService 的 push2SlaveMaxOffset</span></span><br><span class="line">      HAConnection.<span class="keyword">this</span>.haService.notifyTransferSome(HAConnection.<span class="keyword">this</span>.slaveAckOffset);</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.selector.select(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">          processReadEvent();</span><br><span class="line"></span><br><span class="line">          ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">WriteSocketService</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一次写的数据都包含 header 和 body TODO</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="slave-相关代码"><a href="#slave-相关代码" class="headerlink" title="slave 相关代码"></a>slave 相关代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HAService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收 master 发送的数据并写到 commit log</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HAClient</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.connectMaster()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isTimeToReportOffset()) &#123;</span><br><span class="line">              <span class="keyword">boolean</span> result = <span class="keyword">this</span>.reportSlaveMaxOffset(<span class="keyword">this</span>.currentReportedOffset); <span class="comment">// 向 master 报告当前的 offset，即写数据</span></span><br><span class="line">              ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.selector.select(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> ok = <span class="keyword">this</span>.processReadEvent(); <span class="comment">// 处理读到的数据</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            waitForRunning(<span class="number">1000</span> * <span class="number">5</span>); <span class="comment">// 连接不 ok 就先等着</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">processReadEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">this</span>.byteBufferRead.hasRemaining()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">int</span> readSize = <span class="keyword">this</span>.socketChannel.read(<span class="keyword">this</span>.byteBufferRead);</span><br><span class="line">          <span class="keyword">if</span> (readSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            dispatchReadRequest(); <span class="comment">// 读数据</span></span><br><span class="line">            ...</span><br><span class="line">          &#125; <span class="keyword">else</span> (readSize == <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchReadRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      HAService.<span class="keyword">this</span>.defaultMessageStore.appendToCommitLog(masterPhyOffset, bodyData); <span class="comment">// 直接 append 数据到 commit log</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="consume-queue"><a href="#consume-queue" class="headerlink" title="consume queue"></a>consume queue</h2><p>ConsumeQueue 记录消息在 CommitLog 中的位置，一个 ConsumeQueue 对象表示一个 Topic 下的一个队列。</p>
<p>ConsumeQueue 按 topic 和 队列 ID 保存在 ${storePath}/consumequeue/${topic}/${queueId} 目录下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CQ_STORE_UNIT_SIZE = <span class="number">20</span>; <span class="comment">// ConsumeQueue 中每一个条目长度是固定的 20</span></span><br><span class="line"></span><br><span class="line">  MappedFileQueue mappedFileQueue; <span class="comment">// 读写内存映射文件</span></span><br><span class="line">  String topic; <span class="comment">//  topic</span></span><br><span class="line">  <span class="keyword">int</span> queueId; <span class="comment">// 队列 id</span></span><br><span class="line">  ConsumeQueueExt consumeQueueExt; <span class="comment">// 保存额外的信息</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 写完 commit log 后会异步触发这个调用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putMessagePositionInfoWrapper</span><span class="params">(DispatchRequest request)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = putMessagePositionInfo(request.getCommitLogOffset(), request.getMsgSize(), tagsCode, request.getConsumeQueueOffset());</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      <span class="keyword">this</span>.defaultMessageStore.getStoreCheckpoint().setLogicsMsgTimestamp(request.getStoreTimestamp());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 将消息在 commit long 中的 offset 和 size 写到 consume queue</span></span><br><span class="line"><span class="comment">   * @param offset 消息在 commit log 中的逻辑位置</span></span><br><span class="line"><span class="comment">   * @param size 消息的大小</span></span><br><span class="line"><span class="comment">   * @param tagsCode 消息的 tagsCode</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">putMessagePositionInfo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> size, <span class="keyword">final</span> <span class="keyword">long</span> tagsCode, <span class="keyword">final</span> <span class="keyword">long</span> cqOffset)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.flip();</span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);</span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.putLong(offset);</span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.putInt(size);</span><br><span class="line">    <span class="keyword">this</span>.byteBufferIndex.putLong(tagsCode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> expectLogicOffset = cqOffset * CQ_STORE_UNIT_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到对应的 MappedFile</span></span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile(expectLogicOffset);</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 顺序写</span></span><br><span class="line">      <span class="keyword">return</span> mappedFile.appendMessage(<span class="keyword">this</span>.byteBufferIndex.array());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SelectMappedBufferResult <span class="title">getIndexBuffer</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> startIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mappedFileSize = <span class="keyword">this</span>.mappedFileSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 offset</span></span><br><span class="line">    <span class="keyword">long</span> offset = startIndex * CQ_STORE_UNIT_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="keyword">this</span>.getMinLogicOffset()) &#123;</span><br><span class="line">      MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.findMappedFileByOffset(offset);</span><br><span class="line">      <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        SelectMappedBufferResult result = mappedFile.selectMappedBuffer((<span class="keyword">int</span>) (offset % mappedFileSize));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>索引文件由 IndexFile 类封装读写，IndexService 负责提供服务</p>
<p>public class IndexService {</p>
<p>  …<br>  int hashSlotNum;<br>  int indexNum;<br>  ArrayList<indexfile> indexFileList = new ArrayList<indexfile>();<br>  ReadWriteLock readWriteLock = new ReentrantReadWriteLock();<br>  …</indexfile></indexfile></p>
<p>  /**</p>
<ul>
<li>查询 key 所表示的消息在 commit log 中的位置</li>
<li><p>begin, end 表示一个时间范围<br>*/<br>public QueryOffsetResult queryOffset(String topic, String key, int maxNum, long begin, long end) {<br>// 保存消息在 commit log 中的位置， 由于一个 key 可能有多个结果，用 List 保存<br>List<long> phyOffsets = new ArrayList<long>(maxNum);</long></long></p>
<p>long indexLastUpdateTimestamp = 0;<br>long indexLastUpdatePhyoffset = 0;<br>maxNum = Math.min(maxNum, this.defaultMessageStore.getMessageStoreConfig().getMaxMsgsNumBatch());<br>try {</p>
<pre><code>this.readWriteLock.readLock().lock();

if (!this.indexFileList.isEmpty()) {
  for (int i = this.indexFileList.size(); i &gt; 0; i--) {

    // 迭代每个 index file
    IndexFile f = this.indexFileList.get(i - 1);
    boolean lastFile = i == this.indexFileList.size();
    if (lastFile) {
      indexLastUpdateTimestamp = f.getEndTimestamp();
      indexLastUpdatePhyoffset = f.getEndPhyOffset();
    }

    // 这个 index 文件在时间范围内，在这个文件找 key
    if (f.isTimeMatched(begin, end)) {
      f.selectPhyOffset(phyOffsets, buildKey(topic, key), maxNum, begin, end, lastFile);
    }

    if (f.getBeginTimestamp() &lt; begin) {
      break;
    }

    if (phyOffsets.size() &gt;= maxNum) {
      break;
    }
  }
}
</code></pre><p>} catch (Exception e) {</p>
<pre><code>log.error(&quot;queryMsg exception&quot;, e);
</code></pre><p>} finally {</p>
<pre><code>this.readWriteLock.readLock().unlock();
</code></pre><p>}</p>
<p>return new QueryOffsetResult(phyOffsets, indexLastUpdateTimestamp, indexLastUpdatePhyoffset);<br>}</p>
<p>/<em> 写完 commit log 后会异步触发这个调用
</em>/<br>public void buildIndex(DispatchRequest req) {<br>IndexFile indexFile = retryGetAndCreateIndexFile();<br>if (indexFile != null) {<br> long endPhyOffset = indexFile.getEndPhyOffset();<br> DispatchRequest msg = req;<br> String topic = msg.getTopic();<br> String keys = msg.getKeys();<br> if (msg.getCommitLogOffset() &lt; endPhyOffset) {</p>
<pre><code>return;
</code></pre><p> }</p>
<p> // 事务控制有消息不索引<br> final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());<br> switch (tranType) {</p>
<pre><code>case MessageSysFlag.TRANSACTION_NOT_TYPE:
case MessageSysFlag.TRANSACTION_PREPARED_TYPE:
case MessageSysFlag.TRANSACTION_COMMIT_TYPE:
    break;
case MessageSysFlag.TRANSACTION_ROLLBACK_TYPE:
    return;
</code></pre><p> }</p>
<p> if (req.getUniqKey() != null) {</p>
<p>   // 有 uniqkey 就用 uniqkey 写索引<br>   indexFile = putKey(indexFile, msg, buildKey(topic, req.getUniqKey())); // buildKey -&gt; topic + “#” + key</p>
<p>   if (indexFile == null) {</p>
<pre><code>log.error(&quot;putKey error commitlog {} uniqkey {}&quot;, req.getCommitLogOffset(), req.getUniqKey());
return;
</code></pre><p>   }<br> }</p>
<p> if (keys != null &amp;&amp; keys.length() &gt; 0) {<br>   String[] keyset = keys.split(MessageConst.KEY_SEPARATOR); //  KEY_SEPARATOR 是空格<br>   for (int i = 0; i &lt; keyset.length; i++) {</p>
<pre><code>String key = keyset[i];
if (key.length() &gt; 0) {

  // 每个 key 写一条索引
  indexFile = putKey(indexFile, msg, buildKey(topic, key));

  if (indexFile == null) {
    log.error(&quot;putKey error commitlog {} uniqkey {}&quot;, req.getCommitLogOffset(), req.getUniqKey());
    return;
  }
}
</code></pre><p>   }<br> }<br>} else {<br> log.error(“…”);<br>}<br>}</p>
<p>// 写索引<br>private IndexFile putKey(IndexFile indexFile, DispatchRequest msg, String idxKey) {</p>
<p>// 写成功为止<br>for (boolean ok = indexFile.putKey(idxKey, msg.getCommitLogOffset(), msg.getStoreTimestamp()); !ok; ) {<br> log.warn(“Index file [“ + indexFile.getFileName() + “] is full, trying to create another one”);</p>
<p> // 写满磁盘了<br> indexFile = retryGetAndCreateIndexFile();<br> if (null == indexFile) {<br>   return null;<br> }</p>
<p> ok = indexFile.putKey(idxKey, msg.getCommitLogOffset(), msg.getStoreTimestamp());<br>}</p>
<p>return indexFile;<br>}</p>
</li>
</ul>
<p>}</p>
<p>public class IndexFile {<br>  int hashSlotSize = 4;<br>  int indexSize = 20;<br>  int invalidIndex = 0;</p>
<p>  int hashSlotNum;  // 槽的最大数量<br>  int indexNum; // 索引最大数量</p>
<p>  MappedFile mappedFile;<br>  FileChannel fileChannel;<br>  MappedByteBuffer mappedByteBuffer;<br>  IndexHeader indexHeader; // 索引文件头</p>
<p>  …</p>
<p>  // 从索引文件查出一个索引<br>  public void selectPhyOffset(final List<long> phyOffsets, final String key, final int maxNum, final long begin, final long end, boolean lock) {<br>    if (this.mappedFile.hold()) { // hold 住<br>      int keyHash = indexKeyHashMethod(key);<br>      int slotPos = keyHash % this.hashSlotNum;<br>      int absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize; // 计算出槽的位置</long></p>
<pre><code>  FileLock fileLock = null;
  try {
    if (lock) {
    }

    int slotValue = this.mappedByteBuffer.getInt(absSlotPos); // 读出槽的值

    if (slotValue &lt;= invalidIndex || slotValue &gt; this.indexHeader.getIndexCount() || this.indexHeader.getIndexCount() &lt;= 1) { // 不合法的值
    } else {
      for (int nextIndexToRead = slotValue; ; ) {
        if (phyOffsets.size() &gt;= maxNum) {
          break;
        }

        int absIndexPos = IndexHeader.INDEX_HEADER_SIZE + this.hashSlotNum * hashSlotSize + nextIndexToRead * indexSize; // 计算索引的位置

        // 读出索引的信息
        int keyHashRead = this.mappedByteBuffer.getInt(absIndexPos);
        long phyOffsetRead = this.mappedByteBuffer.getLong(absIndexPos + 4);
        long timeDiff = (long) this.mappedByteBuffer.getInt(absIndexPos + 4 + 8);
        int prevIndexRead = this.mappedByteBuffer.getInt(absIndexPos + 4 + 8 + 4); // 这是前一个索引的位置信息

        if (timeDiff &lt; 0) {
          break;
        }

        timeDiff *= 1000L;

        long timeRead = this.indexHeader.getBeginTimestamp() + timeDiff;
        boolean timeMatched = (timeRead &gt;= begin) &amp;&amp; (timeRead &lt;= end);

        // 保存结果
        if (keyHash == keyHashRead &amp;&amp; timeMatched) {
          phyOffsets.add(phyOffsetRead);
        }

        if (prevIndexRead &lt;= invalidIndex || prevIndexRead &gt; this.indexHeader.getIndexCount() || prevIndexRead == nextIndexToRead || timeRead &lt; begin) {
          break;
        }

        nextIndexToRead = prevIndexRead; // 下一轮循环
      }
    }
  } catch (Exception e) {
    log.error(&quot;selectPhyOffset exception &quot;, e);
  } finally {
    if (fileLock != null) {
      try {
        fileLock.release();
      } catch (IOException e) {
        log.error(&quot;Failed to release the lock&quot;, e);
      }
    }

    this.mappedFile.release();
  }
}
</code></pre><p>  }</p>
<p>  …</p>
<p>  // 将索引写到索引文件<br>  public boolean putKey(final String key, final long phyOffset, final long storeTimestamp) {<br>    // 一个索引文件的索引数据有限，要检查容量<br>    if (this.indexHeader.getIndexCount() &lt; this.indexNum) {<br>      int keyHash = indexKeyHashMethod(key); // 计算散列，用的是 String.hashCode<br>      int slotPos = keyHash % this.hashSlotNum; // 再用计算槽的位置<br>      int absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize; // 槽的文件中的绝对位置</p>
<pre><code>  FileLock fileLock = null; //  没用到的代码，估计是遗留的

  try {
    // 读槽值
    int slotValue = this.mappedByteBuffer.getInt(absSlotPos);
    if (slotValue &lt;= invalidIndex || slotValue &gt; this.indexHeader.getIndexCount()) {
      slotValue = invalidIndex;
    }

    long timeDiff = storeTimestamp - this.indexHeader.getBeginTimestamp();

    timeDiff = timeDiff / 1000;

    if (this.indexHeader.getBeginTimestamp() &lt;= 0) {
      timeDiff = 0;
    } else if (timeDiff &gt; Integer.MAX_VALUE) {
      timeDiff = Integer.MAX_VALUE;
    } else if (timeDiff &lt; 0) {
      timeDiff = 0;
    }

    // 计算索引的位置
    // 文件头 + 槽最大数（常量） * 槽大小（常量） + 目前索引数 * 索引大小（常量）
    int absIndexPos = IndexHeader.INDEX_HEADER_SIZE + this.hashSlotNum * hashSlotSize + this.indexHeader.getIndexCount() * indexSize;

    // 写索引，位置是 absIndexPos，所以索引是顺序写的
    this.mappedByteBuffer.putInt(absIndexPos, keyHash);
    this.mappedByteBuffer.putLong(absIndexPos + 4, phyOffset);
    this.mappedByteBuffer.putInt(absIndexPos + 4 + 8, (int) timeDiff);
    this.mappedByteBuffer.putInt(absIndexPos + 4 + 8 + 4, slotValue);  // 写前一个槽值，这样就构成一个链表，解决键冲突

    // 写槽，位置是 absSlotPos，值是写索引前的索引数量
    this.mappedByteBuffer.putInt(absSlotPos, this.indexHeader.getIndexCount());

    if (this.indexHeader.getIndexCount() &lt;= 1) {
      this.indexHeader.setBeginPhyOffset(phyOffset);
      this.indexHeader.setBeginTimestamp(storeTimestamp);
    }

    // 更新索引文件头
    this.indexHeader.incHashSlotCount();
    this.indexHeader.incIndexCount(); // 写完再 + 1
    this.indexHeader.setEndPhyOffset(phyOffset);
    this.indexHeader.setEndTimestamp(storeTimestamp);

    return true;
  } catch (Exception e) {
    log.error(&quot;putKey exception, Key: &quot; + key + &quot; KeyHashCode: &quot; + key.hashCode(), e);
  } finally {
    if (fileLock != null) {
      try {
        fileLock.release();
      } catch (IOException e) {
        log.error(&quot;Failed to release the lock&quot;, e);
      }
    }
  }
} else {
  log.warn(&quot;Over index file capacity: index count = &quot; + this.indexHeader.getIndexCount() + &quot;; index max num = &quot; + this.indexNum);
}

return false;
</code></pre><p>  }<br>}</p>
<h2 id="check-point-与文件完整性检查"><a href="#check-point-与文件完整性检查" class="headerlink" title="check point 与文件完整性检查"></a>check point 与文件完整性检查</h2><h3 id="文件-checkpoint"><a href="#文件-checkpoint" class="headerlink" title="文件 checkpoint"></a>文件 checkpoint</h3><p>checkpoint 文件保存在 ${storePath}/checkpoint 中，由 StoreCheckpoint 类负责读写。</p>
<p>checkpoint 文件只保存 3 个值，分别是 physicMsgTimestamp，logicsMsgTimestamp，indexMsgTimestamp</p>
<p>physicMsgTimestamp 表示 commit log 中最后一条有效消息的存储时间（落盘时间）</p>
<p>logicsMsgTimestamp 表示 consume queue 中最后一条有效消息的存储时间（逻辑位置）</p>
<p>indexMsgTimestamp 表示索引文件中，最新的消息的索引时间。每个索引文件都有一个 daemon 线程 负责 flush， flush 的时候会设置 check point。</p>
<h3 id="从文件恢复到对象"><a href="#从文件恢复到对象" class="headerlink" title="从文件恢复到对象"></a>从文件恢复到对象</h3><p>DefaultMessageStore 启动后，会生成 ${storePath}/abort 文件，当 DefaultMessageStore 正常退出时， 会删除 abort。所以，如果 abort 文件存在，则说明前一次是异常退出，如果文件不存在，则说明前一次是正常退出。</p>
<p>CommitLog 对象的恢复过程，主要是恢复 mappedFileQueue 对象的 flushedWhere， committedWhere 成员。</p>
<p>首先搜索 ${storePath}/commitlog 目录，将每个文件生成 MappedFIle 对象保存到 MappedFileQueue</p>
<ul>
<li>如果是正常退出，那么从倒数第 3 个 commit log 文件开始恢复。检查每条消息，找到最后的写入位置然后更新 mappedFileQueue 对象的成员</li>
<li>如果是非正常退出，由尾部开始往前检查 commit log 文件，如果文件第一条消息存储时间比 checkpoint 保存的小，就从这个文件开始做恢复。循环检查每条消息，更新 mappedFileQueue 对象的成员</li>
</ul>
<p>ConsumeQueue 的恢复类似</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        
          
        
        <div class="post-tags">
          
            <a href="/tags/rocketmq/" rel="tag"># rocketmq</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/04/source-note-rocket-mq-name/" rel="next" title="【阅读笔记】rocketmq 命名服务 namesrv （三）">
                <i class="fa fa-chevron-left"></i> 【阅读笔记】rocketmq 命名服务 namesrv （三）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/08/source-note-rocket-mq-default-store/" rel="prev" title="【阅读笔记】rocketmq 消息存储服务 （五）">
                【阅读笔记】rocketmq 消息存储服务 （五） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Deer</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消息存储的层次结构"><span class="nav-number">2.</span> <span class="nav-text">消息存储的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CommitLog-格式"><span class="nav-number">2.1.</span> <span class="nav-text">CommitLog 格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConsumeQueue"><span class="nav-number">2.2.</span> <span class="nav-text">ConsumeQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Index"><span class="nav-number">2.3.</span> <span class="nav-text">Index</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消息存储的底层技术"><span class="nav-number">3.</span> <span class="nav-text">消息存储的底层技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存映射文件"><span class="nav-number">3.1.</span> <span class="nav-text">内存映射文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PageCache-以及文件预热"><span class="nav-number">3.2.</span> <span class="nav-text">PageCache 以及文件预热</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LibC-系统调用"><span class="nav-number">3.3.</span> <span class="nav-text">LibC 系统调用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#消息存储的功能实现"><span class="nav-number">4.</span> <span class="nav-text">消息存储的功能实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MappedFile-amp-MappedFileQueue"><span class="nav-number">4.1.</span> <span class="nav-text">MappedFile &amp; MappedFileQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#commit-log"><span class="nav-number">4.2.</span> <span class="nav-text">commit log</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#同步刷盘-VS-异步刷盘"><span class="nav-number">4.3.</span> <span class="nav-text">同步刷盘 VS 异步刷盘</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HA（同步双写-VS-异步复制）"><span class="nav-number">4.4.</span> <span class="nav-text">HA（同步双写 VS 异步复制）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HA"><span class="nav-number">4.5.</span> <span class="nav-text">HA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#master-相关代码"><span class="nav-number">4.5.1.</span> <span class="nav-text">master 相关代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slave-相关代码"><span class="nav-number">4.5.2.</span> <span class="nav-text">slave 相关代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#consume-queue"><span class="nav-number">4.6.</span> <span class="nav-text">consume queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#index"><span class="nav-number">4.7.</span> <span class="nav-text">index</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#check-point-与文件完整性检查"><span class="nav-number">4.8.</span> <span class="nav-text">check point 与文件完整性检查</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件-checkpoint"><span class="nav-number">4.8.1.</span> <span class="nav-text">文件 checkpoint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从文件恢复到对象"><span class="nav-number">4.8.2.</span> <span class="nav-text">从文件恢复到对象</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Deer</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
